%%	RUNNBS
% RUN NBS analyzes the output of hopf_particleswarm script.  Specifically,
% runNBS applies the directed network-based statistic (NBS) to the
% effective connectivity matrices generated by hopf_particleswarm.
% The NBS utilizes an version of cluster-based statistical methods adapted
% to network topology.  This allows the NBS to drastically reduce the
% multiple comparison problem when comparing links, thus dramatically
% improving its sensitivity to distributed effects.  However, it is no more
% sensitive to focal effects than any other method.


%%	SETUP

%% Set paths & directories
clear; clc; close all;

% Shuffle random seed.  Necessary in array parallelization to avoid
% repeating same random seed across arrays.
rng('shuffle');

% Find general path (enclosing folder of current directory)
path{1} = strsplit(pwd, '/');
path{3,1} = strjoin(path{1}(1:end-1),'/');
path{4,1} = strjoin(path{1}, '/');
path{1,1} = strjoin(path{1}(1:end-2),'/');
path{2,1} = fullfile(path{1},'MATLAB');

% Set required subdirectories
path{5,1} = fullfile(path{3},'UCLA','Results','EC');
path{6,1} = fullfile(path{3},'Atlases','AAL');

% Add relevant paths
addpath(genpath(fullfile(path{2}, 'BCT', 'NBS')));
addpath(fullfile(path{2},'spm12'));
addpath(genpath(fullfile(path{2}, 'mArrow3')));
addpath(genpath(fullfile(path{2}, 'permutationTest')));
addpath(genpath(fullfile(path{3}, 'Functions')));
addpath(genpath(fullfile(path{3}, 'LEICA', 'Functions')));


%% Load and format EC data

% Define files to load
fileName = 'LE_ICA_CIC*.mat';
dirName = 'SubjectwithGroupPrior';
fileName = dir(fullfile(path{5}, dirName, fileName));
fileName = fileName.name;

% Load EC data
load(fullfile(path{5}, dirName, fileName), 'spaces','labels','coords_ROI','labels_ROI','EC','I','N','condName','comps','mecDist','memberships','h');

% Convert index format
ind = zeros(max(N.subjects), N.conditions);
[r,col] = find(I);
n = 0;
for c = 1:N.conditions
	ind(1:N.subjects(c),c) = I(r(col==c), c);
    n = n + N.subjects(c);
end
clear r c col n

% Set formatting indices
ind = logical(ind);
i = logical(I);


%% NBS Settings

% Analysis Settings
intercept = false;	% determines whether to use intercept term in NBS

% Check if need intercept term
if intercept == true
	I = horzcat(ones(size(I,1),1), I);
end

% Set arrays for parameter sweeps
tstat = 4:0.5:6;

% Allocate contrast matrices
contrast = zeros((size(comps,1)+size(I,2))*2, size(I,2));
strcont = cell((size(comps,1)+size(I,2))*2, 1);

% Set all-way contrasts
c = 2*(size(comps,1)+1:size(comps,1)+N.conditions);
contrast(c-1, :) = -ones(size(I,2), size(I,2)) + diag(2*ones(N.conditions,1));
contrast(c, :) = ones(size(I,2), size(I,2)) - diag(2*ones(N.conditions,1));
for c = 2*(size(comps,1)+1:size(comps,1)+N.conditions)
    strcont{c-1} = strjoin([condName((c-2*size(comps,1))/2), '> ALL']);
    strcont{c} = strjoin([condName((c-2*size(comps,1))/2), '< ALL']);
end

% Set pairwise contrasts
for c = 2*(1:size(comps,1))
    contrast(c-1, comps(c/2,:)) = [1 -1];
    contrast(c, comps(c/2,:)) = [-1 1];
    strcont{c-1} = strjoin([condName(comps(c/2,1)), '>', condName(comps(c/2,2))]);
    strcont{c} = strjoin([condName(comps(c/2,1)), '<', condName(comps(c/2,2))]);
end


%% Visualization Settings

% Generate MNI coordinates
origin = [63 45.5 35];				% center origin
MNIscale = 5.5/10;					% scale MNI coordinates
sphereScale = 2.5;					% scale sphere size
coords_ROI = MNIscale*coords_ROI;	% scale MNI coordinates
clear MNIscale

% Set brain rendering parameters
cortex.file = fullfile(path{6},'MNI152_T1_2mm_brain_mask.nii');	% file containing cortical atlas
cortex.color = [0.9 0.9 0.9];					% color for cortical rendering
cortex.transparency = 0.1;						% set to 1 for opaque cortex
cortex.val = 0.3;								% set isonormal line spacing
cortex.view = [-90 90];							% set camera angle
rdux = 0.7;						% proportion of surface faces to keep (<1)

% set color index
cind.node = [1 0 0; 0 0 1];
cind.conn = [1 0 1; 0 1 1];

% Set comparisons for visualizations
ttype = 'permutation';      % test on which to base visualization
space = 'IC';               % space in which to base visualization

% Set number of brain images to generate
render = 'layered';         % Number of images to generate per threshold.
							% 'compare' to compare thresholds in single figure
							% 'single' for single figure per threshold
							% 'multiple' for single figure per network
                            % 'layered' for two-level figure: single figure
                            %           per threshold + individual networks

% Set filename for saved figures
fN = strsplit(fileName, '_');


%% Set parameter sweep for NBS

% Format EC data to NxNxM
C = EC; clear EC;
EC = zeros(N.ROI, N.ROI, sum(N.subjects));
for c = 1:N.conditions
	EC(:,:,i(:,c)) = squeeze(C(:,:,c,ind(:,c)));
end
clear c ind n i C

% Set storage arrays
storarray = nan(length(tstat), size(contrast,1));
nbs = cell(length(tstat), size(contrast,1));


%% Analyze network using directed network-based statistic (NBS)

% Set directed NBS parameters
%	C: connectivity matrices, arranged in a 3D (NxNxM) tensor
%	GLM: structure defining the GLM for analyzing connectivity tensor
GLM.perms = 10000;		% number of permutations (scalar)
GLM.X = I;				% design matrix (observations x conditions)
GLM.test = 'ttest';		% type of statistical test to run ('ttest' or 'ftest')
STATS.size = 'Extent';	% method to measure size of cluster significance ('Intensity' or 'Extent')
STATS.alpha = 0.05;		% significance level to test

% Sweep parameters
for c = 1:size(contrast,1)
	GLM.contrast = contrast(c,:);	% contrast vector (1 x conditions)
	for t = 1:length(tstat)
		STATS.thresh = tstat(t);		% threshold test statistic
		nbs{t, c} = NBSdirected(EC, GLM, STATS);	% Run NBS
		
		storarray(t, c) = ~isempty(nbs{t,c});
	end
end
clear t c

% Save results
save(fullfile(path{5}, dirName, fileName(1:end-4)), 'contrast','strcont','ttype','space','nbs','STATS','GLM','tstat','storarray', '-append');


%% Run node strength analyses

% Index strength analyses
index = ["out"; "in"];

% Compute in-strength and out-strength arrays
for i = 1:numel(index)
    strength.(index(i)).array = squeeze(sum(EC, i, 'omitnan'));
end

% Run comparisions
vn = cell(size(comps,1), 1);
for c = 1:size(comps,1)
    for i = 1:numel(index)
        [strength.(index(i)).h(:,c), strength.(index(i)).p(:,c), strength.(index(i)).tstat(:,c), strength.(index(i)).FDR(:,c), strength.(index(i)).Bonferroni(:,c), strength.(index(i)).Sidak(:,c)] = ...
        robustTests(strength.(index(i)).array(:,I(:,comps(c,1))), strength.(index(i)).array(:,I(:,comps(c,2))), N.ROI, 'p',0.05, 'testtype','permutation');
    end
    vn{c} = [labels{comps(c,1)}, ' v. ', labels{comps(c,2)}];
end
vn = string(vn);

% Run multiple-comparison corrections for strength
if size(comps,1) > 1
    for i = 1:numel(index)
        p_dum = reshape(strength.(index(i)).p, [size(comps,1)*N.ROI, 1]);		% reshape p-value array
        [f, B, S] = mCompCorr([], p_dum, 0.05);									% run mutliple comparison tests
        strength.(index(i)).FDR = reshape(f, [N.ROI, size(comps,1)]);			% False-Discovery Rate
        strength.(index(i)).Bonferroni = reshape(B, [N.ROI, size(comps,1)]);	% Bonferroni threshold
        strength.(index(i)).Sidak = reshape(S, [N.ROI, size(comps,1)]);			% Sidak threshold
    end
end
clear f B S p_dum

% Convert comparisons to table
if size(comps,1) > 1
    for i = 1:numel(index)
        strength.(index(i)).p = array2table(strength.(index(i)).p, 'RowNames',labels_ROI, 'VariableNames',vn);						% p-value
        strength.(index(i)).h = array2table(strength.(index(i)).h, 'RowNames',labels_ROI, 'VariableNames',vn);						% uncorrected hypothesis test
        strength.(index(i)).tstat = array2table(strength.(index(i)).tstat, 'RowNames',labels_ROI, 'VariableNames',vn);				% test statistic (t-statistic or Hodges' G)
        strength.(index(i)).FDR = array2table(strength.(index(i)).FDR, 'RowNames',labels_ROI, 'VariableNames',vn);					% False-Discovery Rate
        strength.(index(i)).Bonferroni = array2table(strength.(index(i)).Bonferroni, 'RowNames',labels_ROI, 'VariableNames',vn);	% Bonferroni threshold
        strength.(index(i)).Sidak = array2table(strength.(index(i)).Sidak, 'RowNames',labels_ROI, 'VariableNames',vn);				% Sidak threshold
    end
end

% Visualize strength results for each comparison (if any)
t = 0;
for c = 1:size(comps,1)
    % Tabulate FDR results
    FDR = table(strength.in.FDR{:,vn(c)}, strength.out.FDR{:,vn(c)}, 'RowNames',labels_ROI, 'VariableNames',{'In','Out'});
    
    % Check if any significant results: if not, do not plot
    if nnz(FDR{:,:}) > 0
        t = t+1;
        
        % Find significant differences
        [r, col] = find(FDR{:,:});
        
        % Preallocate instrength, outstrength indices
        instr = nan(N.ROI, size(I,1));
        outstr = instr;
        cg = [];
        
        % Isolate strength results for boxplot
        for c2 = 1:size(comps,2)
            instr(:, I(:,comps(c,c2))) = squeeze(strength.in.array(:, I(:,comps(c,c2))));
            outstr(:, I(:,comps(c,c2))) = squeeze(strength.out.array(:, I(:,comps(c,c2))));
            cg = vertcat(cg, repmat(string(labels{comps(c,c2)}), [nnz(I(:,comps(c,c2))), 1]));
        end
        instr(:, ~sum(I(:,comps(c,:)),2)) = [];
        outstr(:, ~sum(I(:,comps(c,:)),2)) = [];
        
        % Format data, group labels for boxplot
        lbl = repmat(labels_ROI, [size(instr,2), 1]);
        cg = repmat(cg, [N.ROI, 1]);
        lbl = {lbl, cg};
        instr = reshape(instr, [numel(instr), 1]);
        outstr = reshape(outstr, [numel(outstr), 1]);

        % Visualize in-strength results
        S(t) = figure('Position', [0 0 1280 1024]);
        ax = subplot(3, nnz(FDR{:,:}), [1 nnz(FDR{:,:})]);
        boxplot(ax, instr, lbl, 'PlotStyle','compact', 'Notch','on', 'ColorGroup',cg, 'Colors',cind.node); hold on;
        title(['In-Strength: ', vn{c}]);
        scatter(r(col==1), (max(instr,[],'all','omitnan')+0.1).*ones(1,nnz(col==1)), 36, 'r', '*');

        % Visualize out-strength results
        ax = subplot(3, nnz(FDR{:,:}), [1+nnz(FDR{:,:}) 2*nnz(FDR{:,:})]);
        boxplot(ax, outstr, lbl, 'PlotStyle','compact', 'Notch','on', 'ColorGroup',cg, 'Colors',cind.node); hold on;
        title(['Out-Strength: ', vn{c}]);
        scatter(r(col==2), (max(outstr,[],'all','omitnan')+0.1).*ones(1,nnz(col==2)), 36, 'r', '*');

        % Visualize significant nodes
        for n = 1:nnz(FDR{:,:})
            f = figure; hold on;
            hg{1} = histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,2))), 'Normalization','probability');
            hg{2} = histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,1))), 'Normalization','probability');
            sz = min(hg{1}.BinWidth, hg{2}.BinWidth);
            close(f);

            figure(S(t));
            ax = subplot(3, nnz(FDR{:,:}), 2*nnz(FDR{:,:})+n);
            for c2 = 1:size(comps,2)
                histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,c2)),:), 'Normalization','probability', 'BinWidth',sz, 'FaceAlpha',0.5, 'FaceColor',cind.node(c2,:)); hold on;
            end
            legend(labels(comps(c,:)));
            title(['Modeled ', FDR.Properties.VariableNames{col(n)}, '-Strength of ', labels_ROI{r(n)}]);
        end
    end
end
clear n ax r c lbl f cg instr outstr i c2 col t index vn


% Save strength figures
savefig(S, fullfile(path{5}, dirName, strcat(fN{1}, '_strength')), 'compact');
clear S

% Save results
save(fullfile(path{5}, dirName, fileName(1:end-4)), 'strength', '-append');


%% Visualize NBS results

% locate significant components
i = h{strcmpi(spaces, space)}(ttype,:);

% Find average distance between groups
k(1) = comps(1,1); k(2) = comps(1,2);
scomb = nchoosek(1:sum(N.subjects(k)), 2);
scomb(scomb(:,2)<=N.subjects(k(1)),:) = [];
scomb(scomb(:,1)>N.subjects(k(1)),:) = [];
scomb(:,2) = scomb(:,2) - N.subjects(k(1));
d = nan(N.ROI, N.ROI, size(scomb,1));
for s = 1:size(scomb, 1)
	d(:,:,s) = pdist2(squeeze(EC(:,:, scomb(s,1))), squeeze(EC(:,:, scomb(s,2))), mecDist);
end
clear s

[thresh, cont] = find(storarray);
if ~isempty(thresh) && strcmpi(render, 'compare')
	[thresh,~] = unique(thresh);
	F = figure('Position', [0 0 1280 1024]);
	for t = 1:numel(thresh)
        
		% Compute mean distance map
		map = nbs(thresh(t),:);
		for m = 1:numel(map)
			if iscell(map{m})
				for n = 1:numel(map{m})
					map{m}{n} = map{m}{n}.*mean(d, 3, 'omitnan')./10;	% this would be an excellent place to apply recursive programming
				end
			else
				map{m} = map{m}.*mean(d, 3, 'omitnan')./10;
			end
		end
		
		% Plot glass brain
		subplot(3, numel(thresh), t); hold on;
		plot_nodes_in_cortex(cortex, zscore(mean(memberships(:,i),2)), coords_ROI, origin, labels_ROI, sphereScale, [], map, cind, strcont, [], rdux);
		title(['Threshold ', num2str(tstat(t))], 'FontSize',12);
		
		% Set up subplots
		ax(1) = subplot(3, numel(thresh), t+(numel(thresh))); grid on	% Plot significant connections as binarized connectivity map
			xlim([1 N.ROI]); ylim([1 N.ROI]);
			title('NBS Networks', 'FontSize',12);
			set(ax(1), {'YTick','YTickLabel'}, {1:N.ROI, labels_ROI});
            set(ax(1), {'XTick','XTickLabel','XTickLabelRotation'}, {5:5:N.ROI, labels_ROI(5:5:N.ROI), -90});
			pbaspect([1 1 1]);
			% Calculate scatter Marker width in points
			currentunits = get(ax(1),'Units');
            set(ax(1),{'Color', 'Units', 'FontSize'},{'w', 'Points', 5, labels_ROI, labels_ROI(5:5:N.ROI)});
			axpos = get(ax(1),'Position');
			set(ax(1), 'Units', currentunits); hold on;
			markerWidth(1) = 1/diff(xlim(ax(1)))*axpos(3);
		ax(2) = subplot(3, numel(thresh), t+2*(numel(thresh)));	% distance map
			colormap(ax(2),cool);
            hold on; grid on
			imagesc(ax(2), mean(d, 3, 'omitnan')); colorbar; hold on
			xlim([1 N.ROI]); ylim([1 N.ROI]);
			title('Mean EC Distance', 'FontSize',12);
			set(ax(1), {'YTick','YTickLabel','FontSize'}, {1:N.ROI, labels_ROI, 5});
            set(ax(1), {'XTick','XTickLabel','XTickLabelRotation'}, {5:5:N.ROI, labels_ROI(5:5:N.ROI), -90});
			pbaspect([1 1 1]);
			% Calculate scatter Marker width in points
			currentunits = get(ax(2),'Units');
			set(ax(2), {'Units'}, {'Points'});
			axpos = get(ax(2),'Position');
			set(ax(2), 'Units', currentunits); hold on;
			markerWidth(2) = 1/diff(xlim(ax(2)))*axpos(3);
		
        % Plot connectivity matrix & distance map
		for m = 1:numel(map)
            % scale transparency by strength
            for n = 1:numel(map{m})
                a(n) = sum(map{m}{n},'all');
            end
            a = a./max(a,[],'all','omitnan');
            [~,ai(m)] = max(a);

            for n = 1:numel(map{m})
                % Find & plot significant connections
                [y, x] = find(map{m}{n});
                scatter(ax(1), x, y, markerWidth(1)^2, cind.conn(m,:), 'filled', 's');

                % Highlight mean EC matrix
                [x, y] = find(map{m}{n});	% extract significant connections
                s(n,m) = scatter(ax(2), y, x, markerWidth(2)^2, cind.conn(m,:), 's');
            end
		end
		% Plot legend in mean EC matrix
		legend(ax(2), [s(ai(1),1),s(ai(2),2)], strcont, 'Location','bestoutside');
		clear ai
	end
	
	% Save as PNG file, MATLAB figure
	saveas(F, fullfile(path{5}, dirName, strjoin({fN{1},'NBS'},'_')), 'png');
	savefig(F, fullfile(path{5}, dirName, strjoin({fN{1},'NBS'},'_')), 'compact');
	
elseif ~isempty(thresh) && strcmpi(render, 'single')
	[thresh,~] = unique(thresh);
	for t = 1:length(thresh)
		
		% Compute mean distance map
		map = nbs(thresh(t),:);
		for m = 1:numel(map)
			if iscell(map{m})
				for n = 1:numel(map{m})
					map{m}{n} = map{m}{n}.*mean(d, 3, 'omitnan')./10;	% this would be an excellent place to apply recursive programming
				end
			else
				map{m} = map{m}.*mean(d, 3, 'omitnan')./10;
			end
		end
		
		% Plot glass brain
		F(t) = figure('Position', [0 0 1280 1024]);
		subplot(2, 4, [3 4 7 8]); hold on;
		plot_nodes_in_cortex(cortex, zscore(mean(memberships(:,i),2)), coords_ROI, origin, labels_ROI, sphereScale, [], map, cind, strcont, [], rdux);
		title(['NBS Networks, Threshold ', num2str(tstat(t))], 'FontSize',12);
		
		% Set up subplots
		ax(1) = subplot(2, 4, [5 6]); hold on; grid on	% Plot significant connections as binarized connectivity map				
			title(['NBS Networks, Threshold ', num2str(tstat(t))], 'FontSize',12);
			xlim([1 N.ROI]); ylim([1 N.ROI]);
			set(ax(1), {'YTick','YTickLabel'}, {1:N.ROI, labels_ROI});
            set(ax(1), {'XTick','XTickLabel','XTickLabelRotation'}, {5:5:N.ROI, labels_ROI(5:5:N.ROI), -90});
			pbaspect([1 1 1]);
			% Calculate scatter Marker width in points
			currentunits = get(ax(1),'Units');
            set(ax(1),{'Color', 'Units', 'FontSize'},{'w', 'Points', 5});
			axpos = get(ax(1),'Position');
			set(ax(1), 'Units', currentunits); hold on;
			markerWidth(1) = 1/diff(xlim(ax(1)))*axpos(3);
		ax(2) = subplot(2, 4, [1 2]); colormap(ax(2),cool); grid on     % distance map
			imagesc(ax(2), mean(d, 3, 'omitnan')); colorbar; hold on
			xlim([1 N.ROI]); ylim([1 N.ROI]);
			title(['Mean Distance, ', labels{comps(1,1)}, ' to ', labels{comps(1,2)}, ' EC'], 'FontSize',12);
			set(ax(1), {'YTick','YTickLabel','FontSize'}, {1:N.ROI, labels_ROI, 5});
            set(ax(1), {'XTick','XTickLabel','XTickLabelRotation'}, {5:5:N.ROI, labels_ROI(5:5:N.ROI), -90});
			pbaspect([1 1 1]);
			% Calculate scatter Marker width in points
			currentunits = get(ax(2),'Units');
			set(ax(2), {'Units'}, {'Points'});
			axpos = get(ax(2),'Position');
			set(ax(2), 'Units', currentunits); hold on;
			markerWidth(2) = 1/diff(xlim(ax(2)))*axpos(3);
		
		for m = 1:numel(map)
			% scale transparency by strength
            for n = 1:numel(map{m})
                a(n) = sum(map{m}{n},'all');
            end
            a = a./max(a,[],'all','omitnan');
            [~,ai(m)] = max(a);

            for n = 1:numel(map{m})
                % Find & plot significant connections
                [y, x] = find(map{m}{n});
                scatter(ax(1), x, y, markerWidth(1)^2, cind.conn(m,:), 'filled', 's');

                % Highlight mean EC matrix
                [x, y] = find(map{m}{n});	% extract significant connections
                s(n,m) = scatter(ax(2), y, x, markerWidth(2)^2, cind.conn(m,:), 's');
            end
		end
		% Plot legend in mean EC matrix
		legend(ax(2), s(1,:), strcont, 'Location','bestoutside', 'Orientation','horizontal');	
		
		% Save as PNG file, MATLAB figure
		saveas(F(t), fullfile(path{5}, dirName, strcat(fN{1},"_NBS_Threshold", string(join(strsplit(num2str(tstat(t)),'.'),'')))), 'png');
	end
	
	% Save as MATLAB figure
	savefig(F, fullfile(path{5}, dirName, strcat(fN{1},"_NBS")), 'compact');
	
elseif ~isempty(thresh) && strcmpi(render, 'multiple')
	imgs = cell(numel(unique(thresh)), numel(unique(cont)));
	
	for t = 1:length(thresh)
		ind = [thresh(t), cont(t)];
		for f = 1:numel(nbs{ind(1), ind(2)})
			F(f) = figure('Position', [0 0 1280 1024]);

			% Plot significant connections
			ax(1) = subplot(2, 4, [1 2]); colormap(ax(1),bone); hold on; grid on
			imagesc(full(nbs{ind(1), ind(2)}{f})); colorbar;
			title(['NBS Network ', num2str(f)], 'FontSize',12);
			set(ax(1), {'YTick','YTickLabel'}, {1:N.ROI, labels_ROI});
            set(ax(1), {'XTick','XTickLabel','XTickLabelRotation'}, {5:5:N.ROI, labels_ROI(5:5:N.ROI), -90});
			xlim([1 N.ROI]); ylim([1 N.ROI]);
			pbaspect([1 1 1]);

			% Extract significant connections
			[sconns(:,1), sconns(:,2)] = find(nbs{ind(1), ind(2)}{f});
			
			% Calculate scatter marker width in points
			ax(2) = subplot(2, 4, [5 6]); colormap(ax(2),cool); hold on; grid on
			xlim([1 N.ROI]); ylim([1 N.ROI]);
			currentunits = get(ax(2),'Units');
			set(ax(2), {'Units'}, {'Points'});
			axpos = get(ax(2),'Position');
			set(ax(2), 'Units', currentunits); hold on;
			markerWidth(2) = 1/diff(xlim(ax(2)))*axpos(3);

			% Highlight mean EC matrix
			imagesc(mean(d, 3, 'omitnan')); colorbar; hold on
			scatter(sconns(:,2), sconns(:,1), 10, 'g', 's');
			title(['Mean Distance, ', labels{comps(1,1)}, ' to ', labels{comps(1,2)}, ' EC'], 'FontSize',12);
			set(ax(1), {'YTick','YTickLabel'}, {1:N.ROI, labels_ROI});
            set(ax(1), {'XTick','XTickLabel','XTickLabelRotation'}, {5:5:N.ROI, labels_ROI(5:5:N.ROI), -90});
			pbaspect([1 1 1]);

			% Render in SPM
			map = nbs{ind(1),ind(2)}{f}.*mean(d, 3, 'omitnan')./10;
			ax = subplot(2, 4, [3 4 7 8]); hold on
			plot_nodes_in_cortex(cortex, zscore(mean(memberships(:,cell2mat(i{ttype,cont})),2)), coords_ROI, origin, sphereScale, [], map, cind, strcont, [], rdux);
        
			% Title figure
			sgtitle(['Threshold ', num2str(tstat(ind(1))), ', ', strcont{ind(2)}]);

			% Save as PNG file
			saveas(F(f), fullfile(path{5}, dirName, strcat(fileName(1:8), 'T', char(join(strsplit(num2str(tstat(ind(1))),'.'), '')), '_C', char(join(strsplit(num2str(contrast(ind(2),:))), '')), '_N', num2str(f))), 'png');
			clear sconns
		end

		% Place figure(s) in cell array
		imgs{ind(1), ind(2)} = F;

		% Save F
		savefig(F, fullfile(path{5}, dirName, strcat(fileName(1:8), 'T', char(join(strsplit(num2str(tstat(ind(1))),'.'),'')), '_C', char(join(strsplit(num2str(contrast(ind(2),:))), '')))));
		clear F
	end
	
	% Save as MATLAB figure
	savefig(F, fullfile(path{5}, dirName, strcat(fN{1},"_NBS")), 'compact');
end
clear K k n f t scomb ind nsig s thresh cont m n bin x y F fN i ax


%% Save results

% Save figure
if exist('F', 'var')
	fN = strsplit(fileName, '_');
	saveas(F, fullfile(path{5}, dirName, strjoin({fN{1},'NBS'},'_')), 'png');
	savefig(F, fullfile(path{5}, dirName, strjoin({fN{1:end-1},'NBS'},'_')), 'compact');
end
clear c C F S
