%%	RUNNBS
% RUN NBS analyzes the output of hopf_particleswarm script.  Specifically,
% runNBS applies the directed network-based statistic (NBS) to the
% effective connectivity matrices generated by hopf_particleswarm.
% The NBS utilizes an version of cluster-based statistical methods adapted
% to network topology.  This allows the NBS to drastically reduce the
% multiple comparison problem when comparing links, thus dramatically
% improving its sensitivity to distributed effects.  However, it is no more
% sensitive to focal effects than any other method.


%%	SETUP

%% Set paths & directories
clear; clc; close all;

% Shuffle random seed.  Necessary in array parallelization to avoid
% repeating same random seed across arrays.
rng('shuffle');

% Find general path (enclosing folder of current directory)
path{1} = strsplit(pwd, '/');
path{3,1} = strjoin(path{1}(1:end-1),'/');
path{4,1} = strjoin(path{1}, '/');
path{1,1} = strjoin(path{1}(1:end-2),'/');
path{2,1} = fullfile(path{1},'MATLAB');

% Set required subdirectories
path{5,1} = fullfile(path{3},'UCLA','Results','EC');
path{6,1} = fullfile(path{3},'Atlases','AAL');

% Add relevant paths
addpath(genpath(fullfile(path{2}, 'BCT', 'NBS')));
addpath(fullfile(path{2},'spm12'));
addpath(genpath(fullfile(path{2}, 'mArrow3')));
addpath(genpath(fullfile(path{2}, 'permutationTest')));
addpath(genpath(fullfile(path{3}, 'Functions')));
addpath(genpath(fullfile(path{3}, 'LEICA', 'Functions')));


%% Load and format EC data

% Define files to load
fileName = 'LE_ICA_CIC*.mat';
dirName = 'SubjectwithGroupPrior';
fileName = dir(fullfile(path{5}, dirName, fileName));
fileName = fileName.name;

% Load EC data
load(fullfile(path{5}, dirName, fileName), 'spaces','labels','coords_ROI','labels_ROI','EC','I','N','condName','comps','mecDist','memberships','h');

% Convert index format
ind = zeros(max(N.subjects), N.conditions);
[r,col] = find(I);
n = 0;
for c = 1:N.conditions
	ind(1:N.subjects(c),c) = I(r(col==c), c);
    n = n + N.subjects(c);
end
clear r c col n

% Set formatting indices
ind = logical(ind);
i = logical(I);


%% NBS Settings

% Analysis Settings
intercept = false;	% determines whether to use intercept term in NBS

% Check if need intercept term
if intercept == true
	I = horzcat(ones(size(I,1),1), I);
end

% Set arrays for parameter sweeps
tstat = 4:0.5:6;

% Allocate contrast matrices
contrast = zeros((size(comps,1)+size(I,2))*2, size(I,2));
strcont = cell((size(comps,1)+size(I,2))*2, 1);

% Set all-way contrasts
c = 2*(size(comps,1)+1:size(comps,1)+N.conditions);
contrast(c-1, :) = -ones(size(I,2), size(I,2)) + diag(2*ones(N.conditions,1));
contrast(c, :) = ones(size(I,2), size(I,2)) - diag(2*ones(N.conditions,1));
for c = 2*(size(comps,1)+1:size(comps,1)+N.conditions)
    strcont{c-1} = strjoin([condName((c-2*size(comps,1))/2), '> ALL']);
    strcont{c} = strjoin([condName((c-2*size(comps,1))/2), '< ALL']);
end

% Set pairwise contrasts
for c = 2*(1:size(comps,1))
    contrast(c-1, comps(c/2,:)) = [1 -1];
    contrast(c, comps(c/2,:)) = [-1 1];
    strcont{c-1} = strjoin([condName(comps(c/2,1)), '>', condName(comps(c/2,2))]);
    strcont{c} = strjoin([condName(comps(c/2,1)), '<', condName(comps(c/2,2))]);
end


%% Visualization Settings

% set color index
cind.node = [1 0 0; 0 0 1];
cind.conn = [1 0 1; 0 1 1];

% Set comparisons for visualizations
ttype = 'permutation';      % test on which to base visualization
space = 'IC';               % space in which to base visualization

% Set number of brain images to generate
render = 'layered';         % Number of images to generate per threshold.
							% 'compare' to compare thresholds in single figure
							% 'single' for single figure per threshold
							% 'multiple' for single figure per network
                            % 'layered' for two-level figure: single figure
                            %           per threshold + individual networks

% Set filename for saved figures
fN = strsplit(fileName, '_');


%% Set parameter sweep for NBS

% Format EC data to NxNxM
C = EC; clear EC;
EC = zeros(N.ROI, N.ROI, sum(N.subjects));
for c = 1:N.conditions
	EC(:,:,i(:,c)) = squeeze(C(:,:,c,ind(:,c)));
end
clear c ind n i C

% Set storage arrays
storarray = nan(length(tstat), size(contrast,1));
nbs = cell(length(tstat), size(contrast,1));


%% Analyze network using directed network-based statistic (NBS)

% Set directed NBS parameters
%	C: connectivity matrices, arranged in a 3D (NxNxM) tensor
%	GLM: structure defining the GLM for analyzing connectivity tensor
GLM.perms = 10000;		% number of permutations (scalar)
GLM.X = I;				% design matrix (observations x conditions)
GLM.test = 'ttest';		% type of statistical test to run ('ttest' or 'ftest')
STATS.size = 'Extent';	% method to measure size of cluster significance ('Intensity' or 'Extent')
STATS.alpha = 0.05;		% significance level to test

% Sweep parameters
for c = 1:size(contrast,1)
	GLM.contrast = contrast(c,:);	% contrast vector (1 x conditions)
	for t = 1:length(tstat)
		STATS.thresh = tstat(t);		% threshold test statistic
		nbs{t, c} = NBSdirected(EC, GLM, STATS);	% Run NBS
		
		storarray(t, c) = ~isempty(nbs{t,c});
	end
end
clear t c

% Save results
save(fullfile(path{5}, dirName, fileName(1:end-4)), 'contrast','strcont','ttype','space','nbs','STATS','GLM','tstat','storarray', '-append');


%% Run node strength analyses

% Index strength analyses
index = ["out"; "in"];

% Compute in-strength and out-strength arrays
for i = 1:numel(index)
    strength.(index(i)).array = squeeze(sum(EC, i, 'omitnan'));
end

% Run comparisions
vn = cell(size(comps,1), 1);
for c = 1:size(comps,1)
    for i = 1:numel(index)
        [strength.(index(i)).h(:,c), strength.(index(i)).p(:,c), strength.(index(i)).tstat(:,c), strength.(index(i)).FDR(:,c), strength.(index(i)).Bonferroni(:,c), strength.(index(i)).Sidak(:,c)] = ...
        robustTests(strength.(index(i)).array(:,I(:,comps(c,1))), strength.(index(i)).array(:,I(:,comps(c,2))), N.ROI, 'p',0.05, 'testtype','permutation');
    end
    vn{c} = [labels{comps(c,1)}, ' v. ', labels{comps(c,2)}];
end
vn = string(vn);

% Run multiple-comparison corrections for strength
if size(comps,1) > 1
    for i = 1:numel(index)
        p_dum = reshape(strength.(index(i)).p, [size(comps,1)*N.ROI, 1]);		% reshape p-value array
        [f, B, S] = mCompCorr([], p_dum, 0.05);									% run mutliple comparison tests
        strength.(index(i)).FDR = reshape(f, [N.ROI, size(comps,1)]);			% False-Discovery Rate
        strength.(index(i)).Bonferroni = reshape(B, [N.ROI, size(comps,1)]);	% Bonferroni threshold
        strength.(index(i)).Sidak = reshape(S, [N.ROI, size(comps,1)]);			% Sidak threshold
    end
end
clear f B S p_dum

% Convert comparisons to table
if size(comps,1) > 1
    for i = 1:numel(index)
        strength.(index(i)).p = array2table(strength.(index(i)).p, 'RowNames',labels_ROI, 'VariableNames',vn);						% p-value
        strength.(index(i)).h = array2table(strength.(index(i)).h, 'RowNames',labels_ROI, 'VariableNames',vn);						% uncorrected hypothesis test
        strength.(index(i)).tstat = array2table(strength.(index(i)).tstat, 'RowNames',labels_ROI, 'VariableNames',vn);				% test statistic (t-statistic or Hodges' G)
        strength.(index(i)).FDR = array2table(strength.(index(i)).FDR, 'RowNames',labels_ROI, 'VariableNames',vn);					% False-Discovery Rate
        strength.(index(i)).Bonferroni = array2table(strength.(index(i)).Bonferroni, 'RowNames',labels_ROI, 'VariableNames',vn);	% Bonferroni threshold
        strength.(index(i)).Sidak = array2table(strength.(index(i)).Sidak, 'RowNames',labels_ROI, 'VariableNames',vn);				% Sidak threshold
    end
end

% Visualize strength results for each comparison (if any)
t = 0;
for c = 1:size(comps,1)
    % Tabulate FDR results
    FDR = table(strength.in.FDR{:,vn(c)}, strength.out.FDR{:,vn(c)}, 'RowNames',labels_ROI, 'VariableNames',{'In','Out'});
    
    % Check if any significant results: if not, do not plot
    if nnz(FDR{:,:}) > 0
        t = t+1;
        
        % Find significant differences
        [r, col] = find(FDR{:,:});
        
        % Preallocate instrength, outstrength indices
        instr = nan(N.ROI, size(I,1));
        outstr = instr;
        cg = [];
        
        % Isolate strength results for boxplot
        for c2 = 1:size(comps,2)
            instr(:, I(:,comps(c,c2))) = squeeze(strength.in.array(:, I(:,comps(c,c2))));
            outstr(:, I(:,comps(c,c2))) = squeeze(strength.out.array(:, I(:,comps(c,c2))));
            cg = vertcat(cg, repmat(string(labels{comps(c,c2)}), [nnz(I(:,comps(c,c2))), 1]));
        end
        instr(:, ~sum(I(:,comps(c,:)),2)) = [];
        outstr(:, ~sum(I(:,comps(c,:)),2)) = [];
        
        % Format data, group labels for boxplot
        lbl = repmat(labels_ROI, [size(instr,2), 1]);
        cg = repmat(cg, [N.ROI, 1]);
        lbl = {lbl, cg};
        instr = reshape(instr, [numel(instr), 1]);
        outstr = reshape(outstr, [numel(outstr), 1]);

        % Visualize in-strength results
        S(t) = figure('Position', [0 0 1280 1024]);
        ax = subplot(3, nnz(FDR{:,:}), [1 nnz(FDR{:,:})]);
        boxplot(ax, instr, lbl, 'PlotStyle','compact', 'Notch','on', 'ColorGroup',cg, 'Colors',cind.node); hold on;
        title(['In-Strength: ', vn{c}]);
        scatter(r(col==1), (max(instr,[],'all','omitnan')+0.1).*ones(1,nnz(col==1)), 36, 'r', '*');

        % Visualize out-strength results
        ax = subplot(3, nnz(FDR{:,:}), [1+nnz(FDR{:,:}) 2*nnz(FDR{:,:})]);
        boxplot(ax, outstr, lbl, 'PlotStyle','compact', 'Notch','on', 'ColorGroup',cg, 'Colors',cind.node); hold on;
        title(['Out-Strength: ', vn{c}]);
        scatter(r(col==2), (max(outstr,[],'all','omitnan')+0.1).*ones(1,nnz(col==2)), 36, 'r', '*');

        % Visualize significant nodes
        for n = 1:nnz(FDR{:,:})
            f = figure; hold on;
            hg{1} = histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,2))), 'Normalization','probability');
            hg{2} = histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,1))), 'Normalization','probability');
            sz = min(hg{1}.BinWidth, hg{2}.BinWidth);
            close(f);

            figure(S(t));
            ax = subplot(3, nnz(FDR{:,:}), 2*nnz(FDR{:,:})+n);
            for c2 = 1:size(comps,2)
                histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,c2)),:), 'Normalization','probability', 'BinWidth',sz, 'FaceAlpha',0.5, 'FaceColor',cind.node(c2,:)); hold on;
            end
            legend(labels(comps(c,:)));
            title(['Modeled ', FDR.Properties.VariableNames{col(n)}, '-Strength of ', labels_ROI{r(n)}]);
        end
    end
end
clear n ax r c lbl f cg instr outstr i c2 col t index vn


% Save strength figures
savefig(S, fullfile(path{5}, dirName, strcat(fN{1}, '_strength')), 'compact');
clear S

% Save results
save(fullfile(path{5}, dirName, fileName(1:end-4)), 'strength', '-append');


%% Visualize NBS results

% locate significant components
i = h{strcmpi(spaces, space)}(ttype,:);

% Locate thresholds & contrasts with significant differences
[~, ind] = find(storarray);
ind = unique(ind); ind = ind(logical(mod(ind,2)));

nm = cell(1,max(unique((ind))));

% Identify contrast of interest
for c = 1:length(ind)
    
    % Generate node color map
    nCol = zeros(N.ROI, 3);
    cont = strjoin(condName(logical(contrast(ind(c),:))), " v. ");          % Generate contrast label
    nCol(zscore(mean(memberships(:,cell2mat(i{ttype,cont})),2))<0,:) = repmat(cind.node(1,:), sum(zscore(mean(memberships(:,cell2mat(i{ttype,cont})),2))<0),1);
    nCol(zscore(mean(memberships(:,cell2mat(i{ttype,cont})),2))>0,:) = repmat(cind.node(2,:), sum(zscore(mean(memberships(:,cell2mat(i{ttype,cont})),2))>0),1);
    
    % Isolate contrasts of interest
   	a = (sum(abs(contrast) == abs(contrast(ind(c),:)),2)) == N.conditions;
    
    % Identify threshold of interest
    thresh = find(storarray(:,ind(c)));
    for t = 1:length(thresh)
        
        %% Combined image
        % Open figure & set axes
        F(ind(c),t,1) = figure('Position', [0 0 1240 1024]);
        ax(1,1) = subplot(6, 5, [1:2, 6:7, 11:12, 16:17, 21:22]); hold on;              % brain space network
        ax(2,1) = subplot(6, 5, [3:5, 8:10, 13:15, 18:20, 23:25]); hold on; grid on;	% adjancecy matrix
        ax(3,1) = subplot(6, 5, 26:30); hold on;                                        % membership bar chart

        % Set up adjacency matrix chart
        set(ax(2,1), {'YLim','YTick','YTickLabel','FontSize'}, {[0.6 N.ROI+0.5], 1:N.ROI, labels_ROI, 5});
        set(ax(2,1), {'XLim','XTick','XTickLabel','XTickLabelRotation'}, {[0.5 N.ROI+0.5], 5:5:N.ROI, labels_ROI(5:5:N.ROI), -45});
        set(ax(2,1), {'Color', 'FontSize'},{'w', 6});
        title(ax(2,1), "Significant Connections", 'FontSize',12);
        pbaspect(ax(2,1), [1 1 1]);
        
        % Set up node membership chart
        set(ax(3,1),{'Color', 'FontSize'},{'w', 6});
        set(ax(3,1), {'XLim','XTick','XTickLabel','XTickLabelRotation'}, {[1 N.ROI], 1:N.ROI, labels_ROI(5:5:N.ROI), -45});
        yticklabels(ax(3,1), []);
        title(ax(3,1), "Node Memberships", 'FontSize',12);

        % Calculate scatter marker width in points
        currentunits = get(ax(2,1),'Units');
        set(ax(2,1), {'Units'}, {'Points'});
        axpos = get(ax(2,1),'Position');
        set(ax(2,1), 'Units', currentunits); hold on;
        markerWidth = 1/diff(xlim(ax(2,1)))*axpos(3)-1;
        
        % Isolate contrasts of interest
        map = nbs(thresh(t),a);
        s = scatter([],[]);
        nm{c,t} = zeros(N.ROI, N.conditions);

        % Extract significant connections
        for m = 1:numel(map)
            for n = 1:numel(map{m})
                [y, x] = find(map{m}{n});

                % Plot significant connections
                s(1,m) = scatter(ax(2,1), x, y, markerWidth(1)^2, cind.conn(m,:), 'filled', 's');

                % Label which nodes in which communities
                nm{c,t}(unique(y),m) = nm{t}(unique(y),m)+ones(length(unique(y)), 1);
            end
        end

        % Plot node roles
        b = bar(ax(3,1), 1:N.ROI, nm{t}');              % connection type
        s2 = scatter(ax(3,1), 1:N.ROI, zeros(1,N.ROI), 'filled');	% node type
        for c2 = 1:nnz(a)
            b(c2).FaceColor = cind.conn(c2,:);
        end
        s2.CData = nCol; clear c2 s2

        % Render overall network in SPM
        axes(ax(1,1));
        plot_nodes_in_cortex(cortex, zscore(mean(memberships(:,cell2mat(i{ttype,cont})),2)), coords_ROI, origin, sphereScale, [], map, cind, strcont, [], rdux);
        sgtitle(F(ind(c),t,1), ['Threshold: t-statistic = ', num2str(tstat(thresh(t)))]);
        title(ax(1,1), "All Components", 'FontSize',12);

        % Plot legend in connectivity matrix
        legend(ax(2,1), s, strcont(a), 'Location','southoutside', 'Color','w', 'FontSize',10);   %  'Orientation','horizontal',
        clear s lgnd s2
        
        %% Individual components
        F(ind(c),t,2) = figure('Position', [0 0 1280 1024]);
        T = tiledlayout(F(ind(c),t,2), 'flow');

        % Render individual components
        for c2 = 1:size(map,2)
            for f = 1:numel(map{:,c2})
                % Generate directed graphs for each component
                G = digraph(map{c2}{f}, labels_ROI);

                % Isolate nodes & links of interest
                [r,cl] = find(map{c2}{f});
                S = subgraph(G, labels_ROI(union(r,cl)));

                % Plot directed graphs per component
                ax(f,2) = nexttile(T); hold on
                plot(S, 'Layout','force', 'UseGravity',true, 'EdgeColor',cind.conn(c2,:), 'NodeColor',nCol(union(r,cl),:));
                title(strcat("Contrast: ", strcont{c2}), 'FontSize',12);
                subtitle(strcat("Component ", num2str(f)), 'FontSize',8);
            end
        end
    end
end
clear c f colind m n map a col climits ncomp T s r cl G S c2 t a


%% Save results

% Save figure
if exist('F', 'var')
	fN = strsplit(fileName, '_');
	saveas(F, fullfile(path{5}, dirName, strjoin({fN{1},'NBS'},'_')), 'png');
	savefig(F, fullfile(path{5}, dirName, strjoin({fN{1:end-1},'NBS'},'_')), 'compact');
end
clear c C F S
