%%	RUNNBS
% RUN NBS analyzes the output of hopf_particleswarm script.  Specifically,
% runNBS applies the directed network-based statistic (NBS) to the
% effective connectivity matrices generated by hopf_particleswarm.
% The NBS utilizes an version of cluster-based statistical methods adapted
% to network topology.  This allows the NBS to drastically reduce the
% multiple comparison problem when comparing links, thus dramatically
% improving its sensitivity to distributed effects.  However, it is no more
% sensitive to focal effects than any other method.


%%	SETUP

%% Set paths & directories
clear; clc; close all;

% Shuffle random seed.  Necessary in array parallelization to avoid
% repeating same random seed across arrays.
rng('shuffle');

% Find general path (enclosing folder of current directory)
path{1} = strsplit(pwd, '/');
path{3,1} = strjoin(path{1}(1:end-1),'/');
path{4,1} = strjoin(path{1}, '/');
path{1,1} = strjoin(path{1}(1:end-2),'/');
path{2,1} = fullfile(path{1},'MATLAB');

% Set required subdirectories
path{5,1} = fullfile(path{3},'UCLA','Results','EC');
path{6,1} = fullfile(path{3},'Atlases','AAL');

% Add relevant paths
addpath(genpath(fullfile(path{2}, 'BCT', 'NBS')));
addpath(fullfile(path{2},'spm12'));
addpath(genpath(fullfile(path{2}, 'mArrow3')));
addpath(genpath(fullfile(path{2}, 'permutationTest')));
addpath(genpath(fullfile(path{3}, 'Functions')));
addpath(genpath(fullfile(path{3}, 'LEICA', 'Functions')));


%% Load and format EC data

% Define files to load
fileName = 'LE_ICA_CIC*.mat';
dirName = 'SubjectwithGroupPrior';
fileName = dir(fullfile(path{5}, dirName, fileName));
fileName = fileName.name;

% Load EC data
load(fullfile(path{5}, dirName, fileName), 'spaces','labels','coords_ROI','labels_ROI','EC','I','N','condName','comps','mecDist','memberships','h');

% Convert index format
ind = zeros(max(N.subjects), N.conditions);
[r,col] = find(I);
n = 0;
for c = 1:N.conditions
	ind(1:N.subjects(c),c) = I(r(col==c), c);
    n = n + N.subjects(c);
end
clear r c col n

% Set formatting indices
ind = logical(ind);
i = logical(I);


%% NBS Settings

% Analysis Settings
intercept = false;	% determines whether to use intercept term in NBS

% Check if need intercept term
if intercept == true
	I = horzcat(ones(size(I,1),1), I);
end

% Set arrays for parameter sweeps
tstat = 4:0.5:6;

% Allocate contrast matrices
contrast = zeros((size(comps,1)+size(I,2))*2, size(I,2));
strcont = cell((size(comps,1)+size(I,2))*2, 1);

% Set all-way contrasts
c = 2*(size(comps,1)+1:size(comps,1)+N.conditions);
contrast(c-1, :) = -ones(size(I,2), size(I,2)) + diag(2*ones(N.conditions,1));
contrast(c, :) = ones(size(I,2), size(I,2)) - diag(2*ones(N.conditions,1));
for c = 2*(size(comps,1)+1:size(comps,1)+N.conditions)
    strcont{c-1} = strjoin([condName((c-2*size(comps,1))/2), '> ALL']);
    strcont{c} = strjoin([condName((c-2*size(comps,1))/2), '< ALL']);
end

% Set pairwise contrasts
for c = 2*(1:size(comps,1))
    contrast(c-1, comps(c/2,:)) = [1 -1];
    contrast(c, comps(c/2,:)) = [-1 1];
    strcont{c-1} = strjoin([condName(comps(c/2,1)), '>', condName(comps(c/2,2))]);
    strcont{c} = strjoin([condName(comps(c/2,1)), '<', condName(comps(c/2,2))]);
end


%% Visualization Settings

% set color index
cind.node = [1 0 0; 0 0 1];
cind.conn = [1 0 1; 0 1 1];

% Set comparisons for visualizations
ttype = 'permutation';      % test on which to base visualization
space = 'IC';               % space in which to base visualization

% Set number of brain images to generate
render = 'layered';         % Number of images to generate per threshold.
							% 'compare' to compare thresholds in single figure
							% 'single' for single figure per threshold
							% 'multiple' for single figure per network
                            % 'layered' for two-level figure: single figure
                            %           per threshold + individual networks

% Set filename for saved figures
fN = strsplit(fileName, '_');


%% Set parameter sweep for NBS

% Format EC data to NxNxM
C = EC; clear EC;
EC = zeros(N.ROI, N.ROI, sum(N.subjects));
for c = 1:N.conditions
	EC(:,:,i(:,c)) = squeeze(C(:,:,c,ind(:,c)));
end
clear c ind n i C

% Set storage arrays
storarray = nan(length(tstat), size(contrast,1));
nbs = cell(length(tstat), size(contrast,1));


%% Analyze network using directed network-based statistic (NBS)

% Set directed NBS parameters
%	C: connectivity matrices, arranged in a 3D (NxNxM) tensor
%	GLM: structure defining the GLM for analyzing connectivity tensor
GLM.perms = 10000;		% number of permutations (scalar)
GLM.X = I;				% design matrix (observations x conditions)
GLM.test = 'ttest';		% type of statistical test to run ('ttest' or 'ftest')
STATS.size = 'Extent';	% method to measure size of cluster significance ('Intensity' or 'Extent')
STATS.alpha = 0.05;		% significance level to test

% Sweep parameters
for c = 1:size(contrast,1)
	GLM.contrast = contrast(c,:);	% contrast vector (1 x conditions)
	for t = 1:length(tstat)
		STATS.thresh = tstat(t);		% threshold test statistic
		nbs{t, c} = NBSdirected(EC, GLM, STATS);	% Run NBS
		
		storarray(t, c) = ~isempty(nbs{t,c});
	end
end
clear t c

% Save results
save(fullfile(path{5}, dirName, fileName(1:end-4)), 'contrast','strcont','ttype','space','nbs','STATS','GLM','tstat','storarray', '-append');


%% Run node strength analyses

% Index strength analyses
index = ["out"; "in"];

% Compute in-strength and out-strength arrays
for i = 1:numel(index)
    strength.(index(i)).array = squeeze(sum(EC, i, 'omitnan'));
end

% Run comparisions
vn = cell(size(comps,1), 1);
for c = 1:size(comps,1)
    for i = 1:numel(index)
        [strength.(index(i)).h(:,c), strength.(index(i)).p(:,c), strength.(index(i)).tstat(:,c), strength.(index(i)).FDR(:,c), strength.(index(i)).Bonferroni(:,c), strength.(index(i)).Sidak(:,c)] = ...
        robustTests(strength.(index(i)).array(:,I(:,comps(c,1))), strength.(index(i)).array(:,I(:,comps(c,2))), N.ROI, 'p',0.05, 'testtype','permutation');
    end
    vn{c} = [labels{comps(c,1)}, ' v. ', labels{comps(c,2)}];
end
vn = string(vn);

% Run multiple-comparison corrections for strength
if size(comps,1) > 1
    for i = 1:numel(index)
        p_dum = reshape(strength.(index(i)).p, [size(comps,1)*N.ROI, 1]);		% reshape p-value array
        [f, B, S] = mCompCorr([], p_dum, 0.05);									% run mutliple comparison tests
        strength.(index(i)).FDR = reshape(f, [N.ROI, size(comps,1)]);			% False-Discovery Rate
        strength.(index(i)).Bonferroni = reshape(B, [N.ROI, size(comps,1)]);	% Bonferroni threshold
        strength.(index(i)).Sidak = reshape(S, [N.ROI, size(comps,1)]);			% Sidak threshold
    end
end
clear f B S p_dum

% Convert comparisons to table
if size(comps,1) > 1
    for i = 1:numel(index)
        strength.(index(i)).p = array2table(strength.(index(i)).p, 'RowNames',labels_ROI, 'VariableNames',vn);						% p-value
        strength.(index(i)).h = array2table(strength.(index(i)).h, 'RowNames',labels_ROI, 'VariableNames',vn);						% uncorrected hypothesis test
        strength.(index(i)).tstat = array2table(strength.(index(i)).tstat, 'RowNames',labels_ROI, 'VariableNames',vn);				% test statistic (t-statistic or Hodges' G)
        strength.(index(i)).FDR = array2table(strength.(index(i)).FDR, 'RowNames',labels_ROI, 'VariableNames',vn);					% False-Discovery Rate
        strength.(index(i)).Bonferroni = array2table(strength.(index(i)).Bonferroni, 'RowNames',labels_ROI, 'VariableNames',vn);	% Bonferroni threshold
        strength.(index(i)).Sidak = array2table(strength.(index(i)).Sidak, 'RowNames',labels_ROI, 'VariableNames',vn);				% Sidak threshold
    end
end

% Visualize strength results for each comparison (if any)
t = 0;
for c = 1:size(comps,1)
    % Tabulate FDR results
    FDR = table(strength.in.FDR{:,vn(c)}, strength.out.FDR{:,vn(c)}, 'RowNames',labels_ROI, 'VariableNames',{'In','Out'});
    
    % Check if any significant results: if not, do not plot
    if nnz(FDR{:,:}) > 0
        t = t+1;
        
        % Find significant differences
        [r, col] = find(FDR{:,:});
        
        % Preallocate instrength, outstrength indices
        instr = nan(N.ROI, size(I,1));
        outstr = instr;
        cg = [];
        
        % Isolate strength results for boxplot
        for c2 = 1:size(comps,2)
            instr(:, I(:,comps(c,c2))) = squeeze(strength.in.array(:, I(:,comps(c,c2))));
            outstr(:, I(:,comps(c,c2))) = squeeze(strength.out.array(:, I(:,comps(c,c2))));
            cg = vertcat(cg, repmat(string(labels{comps(c,c2)}), [nnz(I(:,comps(c,c2))), 1]));
        end
        instr(:, ~sum(I(:,comps(c,:)),2)) = [];
        outstr(:, ~sum(I(:,comps(c,:)),2)) = [];
        
        % Format data, group labels for boxplot
        lbl = repmat(labels_ROI, [size(instr,2), 1]);
        cg = repmat(cg, [N.ROI, 1]);
        lbl = {lbl, cg};
        instr = reshape(instr, [numel(instr), 1]);
        outstr = reshape(outstr, [numel(outstr), 1]);

        % Visualize in-strength results
        S(t) = figure('Position', [0 0 1280 1024]);
        ax = subplot(3, nnz(FDR{:,:}), [1 nnz(FDR{:,:})]);
        boxplot(ax, instr, lbl, 'PlotStyle','compact', 'Notch','on', 'ColorGroup',cg, 'Colors',cind.node); hold on;
        title(['In-Strength: ', vn{c}]);
        scatter(r(col==1), (max(instr,[],'all','omitnan')+0.1).*ones(1,nnz(col==1)), 36, 'r', '*');

        % Visualize out-strength results
        ax = subplot(3, nnz(FDR{:,:}), [1+nnz(FDR{:,:}) 2*nnz(FDR{:,:})]);
        boxplot(ax, outstr, lbl, 'PlotStyle','compact', 'Notch','on', 'ColorGroup',cg, 'Colors',cind.node); hold on;
        title(['Out-Strength: ', vn{c}]);
        scatter(r(col==2), (max(outstr,[],'all','omitnan')+0.1).*ones(1,nnz(col==2)), 36, 'r', '*');

        % Visualize significant nodes
        for n = 1:nnz(FDR{:,:})
            f = figure; hold on;
            hg{1} = histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,2))), 'Normalization','probability');
            hg{2} = histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,1))), 'Normalization','probability');
            sz = min(hg{1}.BinWidth, hg{2}.BinWidth);
            close(f);

            figure(S(t));
            ax = subplot(3, nnz(FDR{:,:}), 2*nnz(FDR{:,:})+n);
            for c2 = 1:size(comps,2)
                histogram(strength.(index(col(n))).array(r(n),I(:,comps(c,c2)),:), 'Normalization','probability', 'BinWidth',sz, 'FaceAlpha',0.5, 'FaceColor',cind.node(c2,:)); hold on;
            end
            legend(labels(comps(c,:)));
            title(['Modeled ', FDR.Properties.VariableNames{col(n)}, '-Strength of ', labels_ROI{r(n)}]);
        end
    end
end
clear n ax r c lbl f cg instr outstr i c2 col t index vn


% Save strength figures
savefig(S, fullfile(path{5}, dirName, strcat(fN{1}, '_strength')), 'compact');
clear S

% Save results
save(fullfile(path{5}, dirName, fileName(1:end-4)), 'strength', '-append');


%% Visualize NBS results

F = layered(memberships, ttype, h{strcmpi(spaces, space)}(ttype,:), storarray, N, labels, contrast, cind, [8 8], coords_ROI, origin, sphereScale, strcont, rdux);


%% Save results

% Save figure
if exist('F', 'var') && ~isempty(F)
	fN = strsplit(fileName, '_');
	saveas(F, fullfile(path{5}, dirName, strjoin({fN{1},'NBS'},'_')), 'png');
	savefig(F, fullfile(path{5}, dirName, strjoin({fN{1:end-1},'NBS'},'_')), 'compact');
end
clear c C F S
